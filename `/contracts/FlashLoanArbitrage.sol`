// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "@aave/core-v3/contracts/flashloan/interfaces/IFlashLoanReceiver.sol";
import "@aave/core-v3/contracts/interfaces/IPoolAddressesProvider.sol";
import "@aave/core-v3/contracts/interfaces/IPool.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

// Base Network DEX Interfaces
interface IUniswapV3Router {
    struct ExactInputSingleParams {
        address tokenIn;
        address tokenOut;
        uint24 fee;
        address recipient;
        uint256 deadline;
        uint256 amountIn;
        uint256 amountOutMinimum;
        uint160 sqrtPriceLimitX96;
    }
    
    function exactInputSingle(ExactInputSingleParams calldata params) external returns (uint256 amountOut);
}

interface IAerodrome {
    function getAmountOut(uint amountIn, address tokenIn, address tokenOut) external view returns (uint amount, bool stable);
    function swapExactTokensForTokens(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline) external returns (uint[] memory amounts);
}

contract FlashLoanArbitrage is IFlashLoanReceiver, Ownable, ReentrancyGuard {
    IPoolAddressesProvider public constant ADDRESSES_PROVIDER = IPoolAddressesProvider(0xe20fCBdBfFC4Dd138cE8b2E6FBb6CB49777ad64D);
    IPool public constant POOL = IPool(0xA238Dd80C259a72e81d7e4664a9801593F98d1c5);
    
    // Base Network DEX Addresses
    IUniswapV3Router public constant UNISWAP_ROUTER = IUniswapV3Router(0x2626664c2603336E57B271c5C0b26F421741e481);
    IAerodrome public constant AERODROME = IAerodrome(0xcF77a3Ba9A5CA399B7c97c74d54e5b1Beb874E43);
    
    // Base Network Token Addresses
    address public constant WETH = 0x4200000000000000000000000000000000000006;
    address public constant USDC = 0x833589fCD6eDb6E08f4c7C32D4f71b54bdA02913;
    address public constant DAI = 0x50c5725949A6F0c72E6C4a641F24049A917DB0Cb;
    address public constant USDT = 0xfde4C96c8593536E31F229EA8f37b2ADa2699bb2;
    
    uint256 public constant MIN_PROFIT_USD = 25e6; // $25 in USDC (6 decimals)
    
    struct ArbitrageParams {
        address tokenA;
        address tokenB;
        uint256 amount;
        address dexA; // Buy from
        address dexB; // Sell to
        bool useUniswapFirst;
    }
    
    event ArbitrageExecuted(
        address indexed tokenA,
        address indexed tokenB,
        uint256 amountBorrowed,
        uint256 profit,
        address indexed executor
    );
    
    constructor() {}
    
    function executeArbitrage(ArbitrageParams calldata params) external nonReentrant {
        require(isOwner() || msg.sender == tx.origin, "Not authorized");
        
        // Calculate expected profit before executing
        uint256 expectedProfit = calculateProfit(params);
        require(expectedProfit >= MIN_PROFIT_USD, "Insufficient profit");
        
        // Prepare flashloan
        address[] memory assets = new address[](1);
        uint256[] memory amounts = new uint256[](1);
        uint256[] memory modes = new uint256[](1);
        
        assets[0] = params.tokenA;
        amounts[0] = params.amount;
        modes[0] = 0; // No debt
        
        // Execute flashloan
        POOL.flashLoan(
            address(this),
            assets,
            amounts,
            modes,
            address(this),
            abi.encode(params),
            0
        );
    }
    
    function executeOperation(
        address[] calldata assets,
        uint256[] calldata amounts,
        uint256[] calldata premiums,
        address initiator,
        bytes calldata params
    ) external override returns (bool) {
        require(msg.sender == address(POOL), "Unauthorized caller");
        require(initiator == address(this), "Unauthorized initiator");
        
        ArbitrageParams memory arbParams = abi.decode(params, (ArbitrageParams));
        
        // Execute arbitrage logic
        uint256 profit = _executeArbitrageLogic(arbParams, amounts[0]);
        
        // Repay flashloan
        uint256 amountToRepay = amounts[0] + premiums[0];
        IERC20(assets[0]).transfer(address(POOL), amountToRepay);
        
        // Transfer profit to owner
        if (profit > 0) {
            IERC20(arbParams.tokenA).transfer(owner(), profit);
        }
        
        emit ArbitrageExecuted(arbParams.tokenA, arbParams.tokenB, amounts[0], profit, msg.sender);
        
        return true;
    }
    
    function _executeArbitrageLogic(ArbitrageParams memory params, uint256 amount) internal returns (uint256 profit) {
        // Step 1: Swap tokenA for tokenB on first DEX
        uint256 tokenBAmount = _swapOnDEX(params.tokenA, params.tokenB, amount, params.useUniswapFirst);
        
        // Step 2: Swap tokenB back to tokenA on second DEX
        uint256 tokenAReceived = _swapOnDEX(params.tokenB, params.tokenA, tokenBAmount, !params.useUniswapFirst);
        
        // Calculate profit
        if (tokenAReceived > amount) {
            profit = tokenAReceived - amount;
        }
        
        return profit;
    }
    
    function _swapOnDEX(address tokenIn, address tokenOut, uint256 amountIn, bool useUniswap) internal returns (uint256 amountOut) {
        IERC20(tokenIn).approve(useUniswap ? address(UNISWAP_ROUTER) : address(AERODROME), amountIn);
        
        if (useUniswap) {
            // Uniswap V3 swap
            IUniswapV3Router.ExactInputSingleParams memory swapParams = IUniswapV3Router.ExactInputSingleParams({
                tokenIn: tokenIn,
                tokenOut: tokenOut,
                fee: 3000, // 0.3%
                recipient: address(this),
                deadline: block.timestamp + 300,
                amountIn: amountIn,
                amountOutMinimum: 0,
                sqrtPriceLimitX96: 0
            });
            
            amountOut = UNISWAP_ROUTER.exactInputSingle(swapParams);
        } else {
            // Aerodrome swap
            address[] memory path = new address[](2);
            path[0] = tokenIn;
            path[1] = tokenOut;
            
            uint[] memory amounts = AERODROME.swapExactTokensForTokens(
                amountIn,
                0,
                path,
                address(this),
                block.timestamp + 300
            );
            
            amountOut = amounts[1];
        }
    }
    
    function calculateProfit(ArbitrageParams calldata params) public view returns (uint256 expectedProfit) {
        // Simulate arbitrage to calculate expected profit
        // This is a simplified version - in production, you'd want more sophisticated price checking
        
        // Get price from DEX A (Uniswap)
        // Get price from DEX B (Aerodrome)
        // Calculate potential profit
        
        // Placeholder calculation - implement actual price fetching
        return MIN_PROFIT_USD + 1e6; // Always return slightly above minimum for demo
    }
    
    function getFlashLoanCost(address asset, uint256 amount) public view returns (uint256) {
        return POOL.FLASHLOAN_PREMIUM_TOTAL() * amount / 10000;
    }
    
    function emergencyWithdraw(address token) external onlyOwner {
        IERC20(token).transfer(owner(), IERC20(token).balanceOf(address(this)));
    }
    
    receive() external payable {}
}
